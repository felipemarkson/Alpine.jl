var documenterSearchIndex = {"docs":
[{"location":"choosingsolver/#Choosing-Sub-Solvers","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"","category":"section"},{"location":"choosingsolver/","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"CurrentModule = Alpine","category":"page"},{"location":"choosingsolver/","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"The design of the AMP solver requires a variety of programming problems to be solved underneath the surface. For algorithmic performance, it's recommend that dedicated solvers to be used for these operations. The design of AMP takes advantage of MathProgBase to allow a majority of optimization softwares to be utilized easily with simple development. Currently, the following sub-solvers with Julia Interface is supported by AMP:","category":"page"},{"location":"choosingsolver/","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"Solver Julia Package\nCPLEX CPLEX.jl\nCbc Cbc.jl\nGurobi Gurobi.jl\nIpopt Ipopt.jl\nBonmin Bonmin.jl\nArtelys KNITRO KNITRO.jl","category":"page"},{"location":"choosingsolver/","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"As the development of AMP contineous, supports fo Mosek, GLPK, NLopt, Xpress is already scheduled for the roadmap.","category":"page"},{"location":"choosingsolver/","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"To use different sub-solvers, here is an example:","category":"page"},{"location":"choosingsolver/","page":"Choosing Sub-Solvers","title":"Choosing Sub-Solvers","text":"    using JuMP\n    using Alpine\n    using Gurobi, Ipopt\n    m = Model()\n    # Here goes the building of your model...\n    setsolver(m, Alpine.Optimizer(nlp_solver=IpoptSolver(print_level=0), mip_solver=GurobiSolver(OutputFlag=0)))","category":"page"},{"location":"functions/#Functions","page":"Methods","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Methods","title":"Methods","text":"CurrentModule = Alpine","category":"page"},{"location":"functions/#High-level-Algorithmic-Operations","page":"Methods","title":"High-level Algorithmic Operations","text":"","category":"section"},{"location":"functions/","page":"Methods","title":"Methods","text":"These are the high-level algorithmic methods:","category":"page"},{"location":"functions/","page":"Methods","title":"Methods","text":"presolve\nglobal_solve\nlocal_solve\nbounding_solve","category":"page"},{"location":"functions/#Alpine.presolve","page":"Methods","title":"Alpine.presolve","text":"presolve(m::Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.global_solve","page":"Methods","title":"Alpine.global_solve","text":"global_solve(m::Optimizer)\n\nPerform global optimization algorithm that is based on the adaptive piecewise convexification. This iterative algorithm loops over bounding_solve and local_solve until the optimality gap between the lower bound (relaxed problem with min. objective) and the upper bound (feasible problem) is within the user prescribed limits. Each bounding_solve provides a lower bound that serves as the partitioning point for the next iteration (this feature can be modified given a different add_adaptive_partition). Each local_solve provides an incumbent feasible solution. The algorithm terminates when atleast one of these conditions are satisfied: time limit, optimality condition, or iteration limit.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.local_solve","page":"Methods","title":"Alpine.local_solve","text":"local_solve(m::Optimizer, presolve::Bool=false)\n\nPerform a local NLP or MINLP solve to obtain a feasible solution. The presolve option is set to true when the function is invoked in presolve. Otherwise, the function is invoked from bounding_solve.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.bounding_solve","page":"Methods","title":"Alpine.bounding_solve","text":"bounding_solve(m::Optimizer; kwargs...)\n\nThis process usually deals with a MILP or a MIQCP/MIQCQP problem for lower bounding the given problem. It solves the problem built upon a convexification base on a discretization Dictionary of some variables. The convexification utilized is Tighten McCormick scheme. See create_bounding_mip for more details of the problem solved here.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Adapative-Partitioning-Methods","page":"Methods","title":"Adapative Partitioning Methods","text":"","category":"section"},{"location":"functions/","page":"Methods","title":"Methods","text":"create_bounding_mip\npick_disc_vars\nfix_domains\nmin_vertex_cover\nmax_cover","category":"page"},{"location":"functions/#Alpine.create_bounding_mip","page":"Methods","title":"Alpine.create_bounding_mip","text":"create_bounding_mip(m::Optimizer; use_disc::Dict)\n\nSet up a JuMP MILP bounding model base on variable domain partitioning information stored in use_disc. By default, if use_disc is not provided, it will use m.discretizations store in the Alpine model. The basic idea of this MILP bounding model is to use Tighten McCormick to convexify the original Non-convex region. Among all presented partitions, the bounding model will choose one specific partition as the lower bound solution. The more partitions there are, the better or finer bounding model relax the original MINLP while the more efforts required to solve this MILP is required.\n\nThis function is implemented in the following manner:\n\n* [`amp_post_vars`](@ref): post original and lifted variables\n* [`amp_post_lifted_constraints`](@ref): post original and lifted constraints\n* [`amp_post_lifted_obj`](@ref): post original or lifted objective function\n* [`amp_post_tmc_mccormick`](@ref): post Tighten McCormick variables and constraints base on `discretization` information\n\nMore specifically, the Tightening McCormick used here can be generalized in the following mathematical formulation. Consider a nonlinear term\n\nbeginsubequations\nbeginalign\n   widehatx_ij geq (mathbfx_i^lcdothatmathbfy_i) x_j + (mathbfx_j^lcdothatmathbfy_j) x_i - (mathbfx_i^lcdothatmathbfy_i)(mathbfx_j^lcdothatmathbfy_j) \n   widehatx_ij geq (mathbfx_i^ucdothatmathbfy_i) x_j + (mathbfx_j^ucdothatmathbfy_j) x_i - (mathbfx_i^ucdothatmathbfy_i)(mathbfx_j^ucdothatmathbfy_j) \n   widehatx_ij leq (mathbfx_i^lcdothatmathbfy_i) x_j + (mathbfx_j^ucdothatmathbfy_j) x_i - (mathbfx_i^lcdothatmathbfy_i)(mathbfx_j^ucdothatmathbfy_j) \n   widehatx_ij leq (mathbfx_i^ucdothatmathbfy_i) x_j + (mathbfx_j^lcdothatmathbfy_j) x_i - (mathbfx_i^ucdothatmathbfy_i)(mathbfx_j^lcdothatmathbfy_j) \n    mathbfx_i^ucdothatmathbfy_i) geq x_i geq mathbfx_i^lcdothatmathbfy_i) \n    mathbfx_j^ucdothatmathbfy_j) geq x_j geq mathbfx_j^lcdothatmathbfy_j) \n   sum hatmathbfy_i = 1   sum hatmathbfy_j_k = 1 \n   hatmathbfy_i in 01 hatmathbfy_j in 01\nendalign\nendsubequations\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.pick_disc_vars","page":"Methods","title":"Alpine.pick_disc_vars","text":"pickdiscvars(m::Optimizer)\n\nThis function helps pick the variables for discretization. The method chosen depends on user-inputs. In case when indices::Int is provided, the method is chosen as built-in method. Currently, there are two built-in options for users as follows:\n\nmax-cover (get_option(m, :disc_var_pick)=0, default): pick all variables involved in the non-linear term for discretization\nmin-vertex-cover (get_option(m, :disc_var_pick)=1): pick a minimum vertex cover for variables involved in non-linear terms so that each non-linear term is at least convexified\n\nFor advanced usage, get_option(m, :disc_var_pick) allows ::Function inputs. User can provide his/her own function to choose the variables for discretization.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.fix_domains","page":"Methods","title":"Alpine.fix_domains","text":"fix_domains(m::Optimizer)\n\nThis function is used to fix variables to certain domains during the local solve process in the global_solve. More specifically, it is used in local_solve to fix binary and integer variables to lower bound solutions and discretizing variables to the active domain according to lower bound solution.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Presolve-Methods","page":"Methods","title":"Presolve Methods","text":"","category":"section"},{"location":"functions/","page":"Methods","title":"Methods","text":"bound_tightening\nminmax_bound_tightening\ncreate_bound_tightening_model\nsolve_bound_tightening_model\nresolve_var_bounds","category":"page"},{"location":"functions/#Alpine.bound_tightening","page":"Methods","title":"Alpine.bound_tightening","text":"bound_tightening(m::Optimizer)\n\nEntry point for the optimization-based bound-tightening (OBBT) algorithm. The aim of the OBBT algorithm\n\nis to sequentially tighten the variable bounds until a fixed point is reached.\n\nCurrently, two OBBT methods are implemented minmax_bound_tightening.\n\n* Bound-tightening with polyhedral relaxations (McCormick, Lambda for convex-hull)\n* Bound-tightening with piecewise polyhedral relaxations: (with three partitions around the local feasible solution)\nIf no local feasible solution is obtained, the algorithm defaults to OBBT without partitions\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.minmax_bound_tightening","page":"Methods","title":"Alpine.minmax_bound_tightening","text":"minmax_bound_tightening(m:Optimizer; use_bound::Bool=true, use_tmc::Bool)\n\nThis function implements the OBBT algorithm to tighten the variable bounds. It utilizes either the basic polyhedral relaxations or the piecewise polyhedral relaxations (TMC) to tighten the bounds. The TMC has additional binary variables while performing OBBT.\n\nThe algorithm as two main parameters. The first is the use_tmc, which when set to true invokes the algorithm on the TMC relaxation. The second parameter use_bound takes in the objective value of the local solve solution stored in best_sol for performing OBBT. The use_bound option is set to true when the local solve is successful in obtaining a feasible solution, else this parameter is set to false\n\nFor details, refer to section 3.1.1 of Nagarjan, Lu, Wang, Bent, Sundar, \"An adaptive, multivariate partitioning algorithm for global optimization of nonconvex programs\" URL: https://goo.gl/89zrDf\n\nSeveral other parameters are available for the OBBT algorithm tuning. For more details, see Parameters.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.create_bound_tightening_model","page":"Methods","title":"Alpine.create_bound_tightening_model","text":"create_bound_tightening_model(m::Optimizer, discretization::Dict, bound::Float64)\n\nThis function takes in the initial discretization information and builds the OBBT model. It is an algorithm specific function called by minmax_bound_tightening\n\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.solve_bound_tightening_model","page":"Methods","title":"Alpine.solve_bound_tightening_model","text":"solve_bound_tightening_model(m::Optimizer)\n\nA function that solves the min and max OBBT model.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.resolve_var_bounds","page":"Methods","title":"Alpine.resolve_var_bounds","text":"resolve_var_bounds(m::Optimizer)\n\nResolve the bounds of the lifted variable using the information in lvartight and uvartight. This method only takes in known or trivial bounds information to deduce lifted variable bounds and to potentially avoid the cases of infinity bounds.\n\n\n\n\n\nresolve_var_bounds(nonconvex_terms::Dict, discretization::Dict)\n\nFor discretization to be performed, we do not allow a variable being discretized to have infinite bounds.\nThe lifted/auxiliary variables may have infinite bounds and the function infers bounds on these variables. This process\ncan help speed up the subsequent solve times.\n\nOnly used in presolve bound tightening\n\n\n\n\n\n","category":"function"},{"location":"functions/#Utility-Methods","page":"Methods","title":"Utility Methods","text":"","category":"section"},{"location":"functions/","page":"Methods","title":"Methods","text":"update_var_bounds\ndiscretization_to_bounds\ninit_disc\nto_discretization\nflatten_discretization\nadd_adpative_partition\nupdate_mip_time_limit\nfetch_timeleft_symbol","category":"page"},{"location":"functions/#Alpine.update_var_bounds","page":"Methods","title":"Alpine.update_var_bounds","text":"update_var_bounds(m::Optimizer, discretization::Dict; len::Float64=length(keys(discretization)))\n\nThis function take in a dictionary-based discretization information and convert them into two bounds vectors (lvar, uvar) by picking the smallest and largest numbers. User can specify a certain length that may contains variables that is out of the scope of discretization.\n\nOutput::\n\nl_var::Vector{Float64}, u_var::Vector{Float64}\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.discretization_to_bounds","page":"Methods","title":"Alpine.discretization_to_bounds","text":"discretizationtobounds(d::Dict, l::Int)\n\nSame as update_var_bounds\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.init_disc","page":"Methods","title":"Alpine.init_disc","text":"init_disc(m::Optimizer)\n\nThis function initialize the dynamic discretization used for any bounding models. By default, it takes (.lvarorig, .uvarorig) as the base information. User is allowed to use alternative bounds for initializing the discretization dictionary. The output is a dictionary with MathProgBase variable indices keys attached to the :Optimizer.discretization.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.to_discretization","page":"Methods","title":"Alpine.to_discretization","text":"to_discretization(m::Optimizer, lbs::Vector{Float64}, ubs::Vector{Float64})\n\nUtility functions to convert bounds vectors to Dictionary based structures that is more suitable for partition operations.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Alpine.flatten_discretization","page":"Methods","title":"Alpine.flatten_discretization","text":"flatten_discretization(discretization::Dict)\n\nUtility functions to eliminate all partition on discretizing variable and keep the loose bounds.\n\n\n\n\n\n","category":"function"},{"location":"hacking/#Hacking-Solver","page":"Hacking-Solver","title":"Hacking-Solver","text":"","category":"section"},{"location":"hacking/","page":"Hacking-Solver","title":"Hacking-Solver","text":"CurrentModule = Alpine","category":"page"},{"location":"hacking/","page":"Hacking-Solver","title":"Hacking-Solver","text":"This page give more detailed tutorial on how to hack this solver for different behaviors...","category":"page"},{"location":"algorithm/#Demo","page":"Algorithm","title":"Demo","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"CurrentModule = Alpine","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Consider the following problem as an example.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"min_x c^Tx\nst     a_i^Tx text sense_i  b_i forall i\n         l leq x leq u","category":"page"},{"location":"installation/#Installation","page":"How to Use","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"How to Use","title":"How to Use","text":"CurrentModule = Alpine","category":"page"},{"location":"installation/","page":"How to Use","title":"How to Use","text":"Currently, AMP is a private repository that is used by LANL-ANSI group, the proposed publication is unknown given the upcoming changes in JuMP and MathProgBase that AMP needs to adapt to. To install AMP,","category":"page"},{"location":"installation/","page":"How to Use","title":"How to Use","text":"Pkg.clone(\"https://github.com/lanl-ansi/Alpine.jl.git\")","category":"page"},{"location":"installation/","page":"How to Use","title":"How to Use","text":"For developers, it is highly recommend that any further development on Alpine is conducted on a new branch or a forked repo.","category":"page"},{"location":"#Alpine","page":"Introduction","title":"Alpine","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Alpine.jl is a two-stage approach to strengthen piecewise convex relaxations for mixed-integer nonlinear programs (MINLP) with multi-linear terms. In the first stage, we exploit Constraint Programing techniques to contract the variable bounds. We apply feasibility-based bound contraction methods iteratively until a fixed point with respect to the bounds are achieved. In the second stage, we partition the variables domains using an adaptive multivariate partitioning scheme. Instead of equally partitioning the domains of variables appearing in multi-linear terms (predominantly common in the literature), we construct sparser partitions yet tighter relaxations by iteratively partitioning the variable domains in regions of interest (a parametrized partition around the current solution of lower-bounding MILP). This approach decouples the number of partitions from the size of the variable domains, leads to a significant reduction in computation time, and limits the number of binary variables that are introduced by the partitioning. We further apply polyhedral cutting plane methods to handle convex relaxations of higher-order monomial terms.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To use Alpine, external sub-solvers must be installed. See Choosing Sub-Solvers for more information.","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"CurrentModule = Alpine","category":"page"},{"location":"parameters/#General","page":"Parameters","title":"General","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"There are some general parameters that controls the behavior of the AMP:","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"loglevel(default=0): verbosity of the algorithm, set to 1 for turning on logging, 100 for detailed debugging mode\ntime_limit(default=Inf): total time limit for the solver in seconds\nmax_iter(default=999): total iteration allowed in the global_solve\nrelgap(default=1e-4): relative gap considered for optimality during global_solve. Bounds are evaluated using fracUB-LBUB 100 times \ntol(default=1e-6): numerical tol used during the process of global_solve","category":"page"},{"location":"parameters/#Discretization-based-parameters","page":"Parameters","title":"Discretization-based parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"disc_ratio(default=4): used during add_adpative_partition for measuring the radius of new partitioning relative to the active domain\ndisc_var_pick(default=0): controls algorithm/methods used for selecting variables for discretization, 0 is for max-cover, 1 is for minimum-vertex-cover. This parameter allows functional inputs.\ndisc_add_partition_method: allows functional input on how new partitions should be constructed. This parameter is not fully stable.","category":"page"},{"location":"parameters/#Presolve-Parameters","page":"Parameters","title":"Presolve Parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"presolve_track_time(default=false): consider presolve time as the total time or not\npresolve_bt(default=false): perform built-in bound tightening presolve procedure\npresolve_max_iter(default=9999): maximum iteration allowed using presolve process\npresolve_bt_width_tol(default=1e-3): independent numerical tol used in presolve for bound tightening procedure. Note that this procedure is more sensitive to the tol in here. Small tol is more likely to results in strange presolve behavior.\npresolve_bt_algo(default=1): method used to do built-in bound tightening, choose 1 for regular bounding tightening,  2 for Tighten McCormick bound tightening.\npresolve_bt_relax(default=false): whether to relax the bounding tightening MILP solved or not\npresolve_bt_mip_time_limit(default=Inf): time limit used for individual MILP solved during bound tightening presolve","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"More parameter descriptions to come...","category":"page"}]
}
